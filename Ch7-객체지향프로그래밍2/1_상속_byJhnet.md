# 상속
기존의 클래스를 재사용 하는것

## 상속의 정의와 장점
- 조상클래스 : 부모클래스, 상위클래스, 기반클래스
- 자손클래스 : 자식클래스, 하위클래스, 파생된클래스


![](https://velog.velcdn.com/images/bjh0501/post/4e6891ad-0f34-4138-9112-7131fb4ccd8d/image.png)
>상속 그림 표시
자식클래스에서 부모클래스로 화살표가 표시돼있다.

![](https://velog.velcdn.com/images/bjh0501/post/867cfea2-d78e-4ec0-a792-6814d54f0ac4/image.png)

> 다이어그램

- 부모에 변수를 추가하면 자식도 변수가 자동으로 추가된다.
- 한 부모에는 여러 자식클래스가 있을 수 있다.
- 상속에 상속을 받을 수 있다.
- 상속을 받은 자식클래스의 인스턴스를 생성하면 부모+자식클래스가 하나의 인스턴스로 생성된다.

## 클래스간의 관계 - 포함관계
```java
class Circle {
	int x;
    int y;
    int r;
}
```
코드를 
```java
class Circle {
	Point c = new Point();
    int r;
}
```
로 바꾸면 간결하고 코드 관리가 쉽다.

## 클래스간의 관계 설정하기

클래스를 `포함`할것인지 `상속`할것인지 헷갈릴때가있다.

>
- 상속 (a는 b_다._)
  - `원`은 `점`이다.
  - `스포츠카`는 `자동차`다.
- 포함 (a는 b를 _가지고있다._)
  - `원`은 `점`을 가지고 있다.
  - `스포츠카`는 `자동차`를 가지고 있다.
  
구조짤때 이렇게 문장을 만들어서 생각하면 쉽다.

## 단일상속
`c++`은 `다중상속`이 가능한데 `자바`는 `하나`만 가능하다.

## object클래스 - 모든 클래스의 조상
- **모든 클래스는 object클래스가 상속돼있다.**
- 컴파일하면 컴파일러가 자동으로 붙혀준다.
- Object의 멤버들을 사용할 수 있다.

# 오버라이딩
- 조상클래스에서 상속받은 메서드를 변경하는것
- 오버라이딩은 메서드 내용을 새로 쓰는것이다.
## 오버라이딩의 조건
- `이름`, `매개변수`, `리턴타입`이 같아야한다.
- `접근제어자`는 조상 클래스보다 범위가 넓어야한다.
- `예외`는 조상 클래스보다 많이 쓸 수 없다. (넓은 범위로 쓸 수 없다.)
  - `예외`도 조상순으로 조건을 맞춰야한다.
  - ex) 부모에 `IOException`을 쓰면 자식에는 `Exception`을 못쓴다.
- 인스턴스 메서드와 static메서드는 서로 반대로 변경할 수 없다.

## 오버로딩 vs 오버라이딩
- 오버로딩 : 새로운 메서드를 정의
- 오버라이딩 : 메서드를 변경

## super
같은 클래스는 `this`로 썼다면 상속 받은 멤버는 `super`로 쓴다.

## super()
`this()`는 같은 클래스 생성자 호출
`super()`는 상속 클래스 생성자 호출
- 생성자에서만 첫째줄에서만 쓸 수 있다.
- 모든 클래스의 생성자에는 super()를 쓴다. 없다면 컴파일러가 첫줄에 자동으로 `super();`코드를 생성한다.

# package와 import
## package
클래스의 묶음

- 클래스파일 최상단엔 `package` 예약어로 선언해야한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야한다.
- 패키지는 .으로 계층 구분
- 클래스는 파일, 패키지는 디렉터리

## 패키지의 선언
```java
package 패키지명;
```
파일 최상단에 선언해야한다.

### 이름없는패키지
패키지를 선언하지 않으면 자동으로 이름 없는 패키지에 속한다.

`javac -d PackageTest.java`
- -d 옵션은 코드에서 `package 패키지명`을 통해 알아서 폴더를 만들어준다.
- 폴더가 없으면 자동으로 생성된다.
- -d 옵션을 사용하지 않으면 직접 디렉터리를 생성해야한다.

### 클래스패스
- 패키지를 `클래스패스`에 포함해야 클래스파일을 읽는다.
- 보통 환경변수에 설정한다.
- `;`로 구분한다.
- `.`은 현재 경로 추가

클래스패스 : `c:\a`
클래스파일 : `c:\a\b\c\Test.class`
명령어 : `java b.c.Test` Test.class 실행됨

임시로 클래스패스 지정하기 `-cp` 명령어
ex) `java -cp c:\~~임시클래스패스경로 b.c.Test`

## import문
`import 패키지명.클래스명`을 붙혀서 선언할 수 있다.
import문은 프로그램에 성능에 영향을 안끼친다. 다만 컴파일시간이 더 걸린다.

## import문 원리
코드에 import를 선언하면 컴파일러는 해당 코드안에 있는 모든클래스 앞에 패키지를 붙혀준다.
ex )
```java 
import java.util.Date
Date d = new Date(); // java.util.Date d = new java.util.Date();
```

## import문의 선언
1. package
2. import문
3. 클래스선언

순으로 작성한다.

### import문 작성법
`import 패키지명.클래스명`
`import 패키지명.*`
\*을 붙히면 해당 패키지명에 있는 모든 클래스를 import한다.

`import java.*;`으로 import해도 아래 포함된 클래스들은 import 안된다.
`import java.util.*;`
`import java.text.*;`
대신 java안에 클래스가 있다면 `java.클래스`들은 import된다.

> `import java.lang.*` 은 자동 import가 된다.

# 제어자
내일은 여기부터작성
