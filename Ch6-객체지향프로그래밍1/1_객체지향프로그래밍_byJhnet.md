# 객체지향언어
실제 세계는 사물로 이루어져 있으며 발생하는 모든 사건들은 상호작용이다.

## 객체지향언어의 역사
- `1960년대 중반`에 ```시뮬라```라는 최초의 객체지향 프로그래밍언어 등장
- `1980년대 중반`에 `C++`라는 객체지향언어가 관심을 끔
- `1995년`에 `자바` 발표
- `1990년말`에 인터넷이 발전하면서 객체지향이 자리잡음

## 객체지향언어
기존의 언어에서 몇가지를 추가한것이다.

1. 코드 재사용이 높다.
	- 기존의 코드사용
2. 코드 관리 용이
	- 적은 노력으로 코드를 변경
3. 신뢰성이높다
	- 제어자, 메서드를 이용
    - 코드중복 제거
    
    
# 클래스와 객체
## 클래스와 객체의 정의와 용도
- 클래스는 객체를 정의한 것 or 객체의 설계도
- 클래스가 제품설계도라면 객체는 제품

## 객체와 인스턴스
클래스 -> 인스턴스화 -> 인스턴스
`클래스`로 부터 만들어진 `객체`를 `인스턴스`라 한다.

## 객체의 구성요소 - 속성과 기능
클래스란 객체를 정의한 것
객체는 속성과 기능의 집합
속성 - **멤버변수**, 특성, 필드, 상태 (다같은말)
기능 - **텍스트**, 메서드, 행위, 함수 (다같은말)

## 인스턴스의 생성과 사용
```java
Tv t; // 메모리 공간 생성
t = new Tv(); // 힙메모리에 객체저장(힙에 변수들이 저장됨)

t.channel = 7; // 멤버변수 접근

// t -> Tv인스턴스에 접근한다.
// t변수를 통해서 Tv인스턴스를 조작할수 있다.
Tv t2 = new Tv();

// t2가 참조한 Tv인스턴스는 GC에 의해 삭제
// t, t2가 서로 같은 메모리를 바라본다.
t2 = t;

t2.channel = 10; // t, t2의 객체가 변한다.


class Tv {
	String color;
	boolean power;
	int channel;
	
    // 호출하면 스택에 쌓임
	void power() {power=!power;}
	void channelUp() {++channel;}
	void channelDown() {--channel;}
}
```
- 인스턴스는 참조변수(t)를 통해서만 조작가능
- 참조변수(t)는 인스턴스타입(Tv)과 같아야함
- 클래스가 같아도 참조변수가 다르면 서로 다른 값이됨



> 참고 : https://www.baeldung.com/java-stack-heap

## 클래스의 또 다른 정의
### 데이터 처리의 발전과정
변수 -> 배열 -> 구조체 -> 클래스

# 변수와 메서드
변수 종류 : 클래스 변수, 인스턴스변수, 지역변수
```java
class Test {
	int iv; // 인스턴스 변수
    static int cv; // 클래스변수(스태틱변수, 공유변수)
    void method() {
    	int lv = 0; // 지역변수
    }
}

Test test; // 클래스 변수 생성
test = new Test(); // 인스턴스 변수생성
test.method(); // 지역변수 생성
```
## 생성시기
클래스변수 : 클래스가 메모리에 올라갈때

```java
Test test = new Test();
Test test2 = new Test();
test.cv=123;
System.out.println(test2.cv); // 123출력
```
- 클래스의 공용변수
- 프로그램 종료때까지 값이 유지된다.

인스턴스 변수 : 인스턴스가 생성될때
지역 변수 : 변수 선언문이 수행될때 
- 메서드가 종료되면 소멸

## 메서드
1. **하나의 메서드는 한가지 기능만 수행**
2. 반복적인 기능은 하나의 메서드로 정의
3. 관련된 여러 문장을 하나의 메서드로 만들기
- 1번내용은 클린코드에서도 나온다.

메서드는 크게 `선언부`, `구현부`가 있다.
1. 매개변수는 0개 또는 여러개
2. 매개변수는 지역변수로 구분 (메서드 종료시 소멸)
3. 메서드 `return`은 선언된 타입과 같아야한다.

## return 문
메서드는 `return` or `}`를 만나면 종료한다.
```java
int max(int a, int b) {
	if(a > b)
		return a;
	else
    	return b;
}
```

```java
int max(int a, int b) {
    int result = 0;
	if(a > b)
		result = a;
	else 
    	result = b;
    return result;
}
```
> 2번째 코드처럼 return 값을 저장했다가 마지막에 쓰는게 좋다.

```java
void add(int a, int b, int[] result) {
	result[0] = a + b;
}
```
주소값을 이용해 add하는 로직인데 좋은방법인지는 모르겠다.

## 메서드의 호출
static메서드 : `참조변수`없이 `클래스.메서드`로 호출가능
- `인스턴스 변수` 호출`불가`
-  `static 변수` 호출 `가능`

## JVM의 메모리구조
![](https://velog.velcdn.com/images/bjh0501/post/06df119d-e093-4390-9f4a-1b5347c1891d/image.png)

> 참조 : https://velog.io/@peanut_/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D-JVM%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0

### 메서드 영역
- JVM 시작될 때 생성
- 논리적으로는 Heap의 일부
- 상수풀, 필드및 데이터, 클래스 및 인스턴스, 생성자를 저장
- 가득차면 `OutOfMemoryError`

### 콜 스택
- 메서드가 호출될 때 메모리 할당
- 메서드 중간에 연산결과 등을 저장
- 메서드가 끝나면 비워짐
- 가득차면 `StackOverflowError`

#### 순서
1. `메서드`가 호출되면 콜스택에 `push`
2. `다른 메서드`가 호출되면 콜스택에 `push`
3. `다른 메서드`가 끝나면 콜스택에서 `pop`
4. `메서드`가 끝나면 콜스택에서 `pop`

### 힙 영역
- 인스턴스가 생성되는 공간
- 프로그램이 시작될때 인스턴스는 여기에 생성됨
- 가득차면 `OutOfMemoryError: heap space`

각 영역은 서로 구분된다.

> https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html

## 기본형 매개변수와 참조형 매개변수
기본형 매개변수 : 읽기만가능
참조형 매개변수 : 읽기 & 쓰기 가능

```java
class Data {int x;}

class P {
	void change(int x) {
    	x = 10;// 기본형 매개변수
    } 
    void change2(Data d) {
    	d.x = 100; // 클래스를 이용한 참조형 매개변수
	}
    void change3(int[] x) {
    	x[0] = 1000; // 배열을 이용한 참조형 매개변수
	}
}
```

## 재귀호출
자기자신을 계속 호출하는 메서드

## 클래스메서드와 인스턴스 메서드
### 클래스(static) 메서드 
- `static`이 붙어있음 
- `클래스이름.매서드이름`으로 호출
- `static변수`하고만 작업가능

### 인스턴스 메서드
- `인스턴스 변수`하고만 작업가능
- 객체를 생성해야 생성됨

멤버 변수 : static변수, 인스턴스변수

### 사용법
1. 인스턴스 전체에 쓰일변수에만 static을 쓴다.
2. static변수는 인스턴스 생성없이 사용가능
3. 클래스 메서드는 인스턴스 변수사용못함
	- 인스턴스 생성없이 사용가능하기때문이다.
    - static은 jvm생성과 동시에 선언된다.
4. `메서드에 static을 붙히는것`을 고려하자
	- 일반메서드보다 빠르다.
    - 인스턴스 메서드는 메서드 찾는과정이 있음

> MathClass를 보면서 공부하면 좋을듯하다.

## 클래스멤버와 인스턴스 멤버간의 참조와 호출
같은클래스인 경우 인스턴스멤버 없이도 호출가능
- 이미 인스턴스가 생성되있다.

_멤버 : 메서드, 변수 합친것_

인스턴스 멤버 -> 클래스 멤버 호출가능
클래스 멤버 -> 인스턴스멤버 호출할땐 인스턴스가 생성되있어야 한다.

---
```java
int sum = new Math().sum(1,2);
```
식으로 사용가능하다.

# 메서드 오버로딩
내일작성예정
