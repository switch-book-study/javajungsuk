## 자바란?
  - 자바는 1996년 1월에 공식적으로 발표한 객체지향 프로그래밍 언어이다.
  - OS에 독립적이다.
  - 비교적 쉽고 간결하다.
  - 풍부한 클래스 라이브러리(JAVA API)를 기본적으로 제공한다.
  - 모바일(J2ME)이나 대규모 기업환경(J2EE), XML등 다양한 기술을 지원한다.
<br>

  ---
  
## 자바의 역사
  - 1991년 썬 마이크로 시스템즈의 엔지니어들에 의해 고안된 소형기기를 타겟으로 하는 오크(Oak)라는 언어에서부터 시작되었다.
  - C++의 장점을 도입하고 단점을 보완하며 만들어진 언어다.
  - 여러 운영체제를 사용하는 컴퓨터들이 통신하는 인터넷이 등장하자 운영체제에 독립적인 장점을 지닌 Oak를 인터넷에 적합하도록 개발방향을 바꾸면서 이름을 JAVA로 바꿨다.
  - 그당시 자바로 작성된 애플릿은 정적인 웹페이지에 사운드와 애니메이션등의 멀티미디어적인 요소들을 제공할 수 있는 유일한 방법이었기 때문에 많은 인기를 얻었다.
  - 플래시와 같은 멀티미디어 플러그인이 등장하며 애플릿의 입지가 줄어들고 대신 서버 쪽 프로그래밍을 위한 서블릿(Servlet)과 JSP(Java Server Pages)가 더 많이 사용됐다.
<br>


---

## 자바언어의 특징 
  ### 운영체제에 독립적
   - "write once, run anywhere"
   - 자바 응용프로그램은 운영체제나 하드웨어가아닌 JVM이랑만 통신한다.
   - JVM이 자바 응용프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할수있도록 변환하여 전달한다.
   - 자바로 작성된 프로그램은 운영체제에 독립적이지만 JVM은 운영체제에 종속적이어서 썬에서는 여러 운영체제에 설치할수있는 서로 다른버전의 JVM을 제공하고있다.
  ### 객체지향언어
   - 자바는 객체지향개념의 특징인 상속, 캡슐화, 다형성이 잘 적용되어있다.
  ### 비교적 낮은 러닝커브
   - 자바의 연산자와 기본구문은 C++에서 가져오고, 객체지향관련 구문은 스몰톡이라는 객체지향언어에서 가져왔다.
   - 객체지향개념을 보다 쉽게 활용할 수 있도록 한 언어이다.
  ### Garbage Collection
   - 자바는 가비지컬렉터가 자동으로 메모리를 관리해주기때문에 일반적으로 메모리를 따로 관리하지 않아도 된다.
  ### 네트워크와 분산처리 지원
   - 네트워크 프로그래밍 라이브러리를통해 비교적 짧은 시간에 네트워크관련 프로그램을 쉽게 개발할수있다.
  ### 멀티쓰레드 지원
   - 일반적으로 멀티쓰레드의 지원은 사용되는 운영체제에 따라 구현방법도 상이하며 처리방식도 다르다.
   - 자바에서 개발되는 멀티쓰레드 프로그램은 시스템과 관계없이 구현가능하며 관련 라이브러리가 제공되므로 구현이 쉽다.
   - 여러 쓰레드에 대한 스케줄링을 자바 인터프리터가 담당하게 된다.
  ### 동적로딩 지원
   - 자바로 작성된 애플리케이션은 여러 개의 클래스로 구성되어있다.
   - 자바는 동적로딩을 지원하므로 실행시에 모든 클래스가 로딩되는것이 아닌 필요한 시점에 클래스를 로딩하여 사용할 수 있다는 장점이있다.
   - 자바는 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 된다.
<br>


---

## JVM (java virtual machine)
  - JVM은 자바를 실행하기위한 가상 컴퓨터이다.
  - ![image](https://user-images.githubusercontent.com/95848796/196719328-e70ed16d-b681-4a25-ba32-fb5bb656cb39.png)
  - java애플리케이션은 JVM을 한번 더 거치고, 컴파일된 상태가 아닌 실행시에 해석되기때문에 일반적인 로우레벨 애플리케이션에 비해 속도가 느리다는 단점이 있다.
  - 그러나 요즘엔 바이트코드(컴파일된 자바코드)를 하드웨어의 기계어로 바로 변환해주는 JIT컴파일러와 향상된 최적화 기술이 적용되어서 속도의 격차를 많이 줄였다.
  - JVM은 OS에 종속적이기때문에 해당 OS에서 실행가능한 JVM이 필요하다.

<br>


---

## 자바 프로그램의 실행과정
  - 자바 애플리케이션을 실행시켰을때 내부적인 진행순서
  ```
  1. 프로그램의 실행에 필요한 클래스(*.class)를 업로드한다.
  2. 클래스파일을 검사한다.(파일형식, 악성코드 체크)
  3. 지정된 클래스에서 main(String[] args)를 호출한다.
  ```
  - 메인메서드의 첫줄부터 마지막줄까지 모두 실행되면 프로그램이 종료되고 사용했던 자원들을 모두 반환한다.
  - AWT나 Swing처럼 멀티쓰레드를 이용하는 기술로 작성된 Java어플리케이션은 메인메서드가 종료되어도 실행중인 다른 쓰레드가 존재하면 프로그램이 종료되지 않는다.

<br>


---


## 🍳 Garbage Collection?
  ### GC를 사용하지 않는다면?
   - 메모리를 할당해놓고 실수로 해제하지 않아 메모리 누수 발생
   - 해제했던 메모리를 실수로 다시 사용하거나 다시 해제하는경우 버그 발생
   - 이런경우 디버깅하기 쉽지않다...
  ### Heap영역에서 사용하지 않는 객체를 삭제해준다
   - ![image](https://user-images.githubusercontent.com/95848796/196724466-e0864398-91ea-44ec-b905-39df56db85a5.png)
   - Heap메모리는 new를 통해 동적으로 생성되는 객체가 저장되는 공간이다.
   - Heap에 저장된 데이터는 메모리 관리가 필요한 GC대상이다.
   - Heap메모리는 모든 쓰레드가 공유하는 공간이다.
   - Heap메모리는 JVM이 실행될때 생성된다.
  ### JVM Heap 영역
   - ![image](https://user-images.githubusercontent.com/95848796/196725156-4a4feed7-4e2e-47f4-8354-8b79c4f45085.png)
   - JVM의 HEap영역은 2가지 전제로 설계되었다.
   - 1. 대부분의 객체는 금방 접근 불가한 상태가된다.
   - 2. 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.
   - 객체는 대부분 일회성이며, 메모리에 오랫동안 남아있는 경우는 드물다.
   - 객체의 생존기간에따라 Heap을 Young, Old 영역으로 나눈다.
  ### Young 영역
   - 새롭게 생성된 객체가 할당되는 영역이다.
   - Young영역에 대한 GC를 Minor GC라고 한다.
   - eden영역은 Young영역 중에서도 최근 생성된 객체들이 위치한다.
   - servivor영역은 eden영역에서 생존한 객체들이 당분간 생존해 있는곳이다.
   - 아직 어디선가 사용하고있는 객체를 reachable이라 한다.
   - 아무도 사용하지 않고 공간만 차지하는 객체를 Unreachable이라 한다. 
  ### Old영역
   - Young영역에서 Reachable상태를 유지하여 살아남은 객체가 복사되는 영역이다.
   - 특정 횟수 이상을 살아남은 reference가 살아있는 영역이다.
   - Old영역에 대한 GC를 Major GC 혹은 Full GC라고 한다.
<br>

## 🍳 Garbage Collection 동작원리
  ### Stop The World
   - GC를 실행하기위해 JVM이 애플리케이션의 실행을 멈추는 작업을 말한다.
   - GC가 실행될때는 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되고 GC가 완료되면 작업이 재개된다.
  ### Mark And Sweep
   - Mark? 사용되는 메모리와 사용되지 않는 메모리를 식별
   - Sweep? 사용되지 않는 메모리를 해제
   - Stop The World로 모든 작업을 중단시키면 GC는 스택의 모든 변수 또는 Reachable객체를 탐색후 MarkAndSweep 한다.
  ### Minor GC
   - Eden영역이 가득차면 Minor GC가 발생한다.
   - 사용되지 않는 메모리는 해제되고, Eden영역에 존재하는 객체는 Survivor영역으로 옮겨진다.
   - 과정을 반복하며 계속해서 살아남은 객체는 Old영역으로 이동된다.
  ### Major GC
   - Old영역 메모리가 부족해지면 발생한다.
   - Old영역은 Young영역보다 크기고 Young영역을 참조할 수 있기때문에 일반적으로 MinorGC보다 시간이 오래 걸린다.
